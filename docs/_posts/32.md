## 描述

> 输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个

示例

```
[3, 32, 321]

=> 321323

[1,14,3,23,34,324]

=> 11423324334
```

## Tag

[数组](/_posts/sort#数组)

## 思路

<details>
<summary>查看解析</summary>

这个题先不看特殊的解法（dp，回溯等）,先看简单的贪心应该怎么做（即举几个例子分析规律）

[1,14,3,23,34,324]

=> 11423324334

以这个例子为例，我们可以从朴素的寻找过程中看到一些规律

-   首先对比数组中每个元素的首位字母的大小，我们取其中最小的，这里是 1 和 14
-   如果存在首位一样小的，比如 1 和 14，我们就开始对比第二位，如果是 1 开头，则 14 必须接在它后面，这样组合的数字 114 第二位为 1，如果是 14 开头，则 1 必须接在它后面，这样组合的数字 141 第二位为 4，显然 114 更小，我们取这两个值的组合为 114
-   此时剩余的数组为[3,23,34,324]，我们再次找到首位最小的值，此时为 23，组合后的数字为 11423
-   此时剩余的数组为[3,34,324]，首位最小的值有三个 3，34，324，首位相同我们就比较第二位，34 第二位是 4，324 第二位是 2，3 虽然没有第二位但是我们知道 3 做开头，第二位必定是剩下的两个之一，也就是说其第二位一定是 3，第二位最小的是 324，组合后的数字为 11423324，并且剩余的 3 和 34 排序为 3 和 34，再组合为 11423324334
-   此时剩余的数组为[]，结束遍历

总结一下流程就是，我们对全部元素按照首位数字大小从小到大排序，如果首位元素相同的元素只有一个则直接加入，如果存在多个则按位数进行排序，最后按顺序依次排序并且加入到最终的数字中

上述方法为我们手动判断输入示例的情况，那么对于可以使用高阶函数的 JS 来说，有没有更好的解法呢？

之前我们描述的思路中，因为相同首位数字的元素可能有多个，所以在整体排序的过程中可能逻辑稍微有点复杂，但是我们用冒泡的思维去考虑排序过程的话，就会发现场景简单了很多，因为我们只需要对比两个元素，这就非常简单了，比如 32 和 324，这两个元素的组合怎么样才会最小呢？我们只需要对比 32324 和 32432 即可

这样，我们通过冒泡式的只对比两个元素的大小将场景简单化，可以轻松地解决此问题，时间复杂度为 O(n^2)，但是是原地排序

</details>

## 解法

<details>
<summary>查看解析</summary>

> 方法 1

```js
function PrintMinNumber(numbers) {
	function sort(num1, num2) {
		if (num1 === num2) return true
		arr1 = String(num1)
		arr2 = String(num2)
		if (arr1[0] !== arr2[0]) {
			return arr1[0] > arr2[0]
		} else {
			let [i, j] = [1, 1]
			let [n1, n2] = [0, 0]
			while (n1 === n2 && i <= arr1.length && j <= arr2.length) {
				n1 = i >= arr1.length ? arr1[0] : arr1[i++]
				n2 = j >= arr2.length ? arr2[0] : arr2[j++]
			}
			return n1 > n2
		}
	}
	if (numbers.length === 0) return ""
	return Number(numbers.sort(sort).join(""))
}
```

> 方法 2

```js
function PrintMinNumber(numbers) {
	function sort(num1, num2) {
		if (num1 === num2) return true
		arr1 = String(num1)
		arr2 = String(num2)
		return arr1 + arr2 > arr2 + arr1
	}
	if (numbers.length === 0) return ""
	return Number(numbers.sort(sort).join(""))
}
```

</details>
